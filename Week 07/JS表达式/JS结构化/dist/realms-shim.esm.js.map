{"version":3,"file":"realms-shim.esm.js","sources":["../src/utilities.js","../src/childRealm.js","../src/callAndWrapError.js","../src/commons.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandler.js","../src/safeEval.js","../src/safeFunction.js","../src/transforms.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n/**\n * safeStringifyFunction()\n * Remove code modifications introduced by ems and nyx in\n * test mode which intefere with Function.toString().\n */\nexport function safeStringifyFunction(fn) {\n  let src = `'use strict'; (${fn})`;\n\n  // esm module creates \"runtime\" as \"_\" + hex(3) + \"\\u200D\"\n\n  // Restore eval which is modified by esm module.\n  // (0, eval) => (0, <runtime>.e)\n  src = src.replace(/\\(0,\\s*_[0-9a-fA-F]{3}\\u200D\\.e\\)/g, '(0, eval)');\n\n  // Restore globals such as Reflect which are modified by esm module.\n  // Reflect => <runtime>.e.Reflect\n  src = src.replace(/_[0-9a-fA-F]{3}\\u200D\\.g\\./g, '');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  return src;\n}\n","import { safeStringifyFunction } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const { callAndWrapError } = unsafeRec;\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  const { create, defineProperties } = Object;\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, [unsafeRec, r, options]);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, [unsafeRec, r, options]);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, [this]);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, [this, x, endowments, options]);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nexport const buildChildRealmString = safeStringifyFunction(buildChildRealm);\n","import { safeStringifyFunction } from './utilities';\n\nfunction buildCallAndWrapError() {\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. Don't ever run this\n  // function *after* user code has had a chance to pollute its environment,\n  // or it could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { getPrototypeOf } = Object;\n  const { apply } = Reflect;\n  const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n  const mapGet = uncurryThis(Map.prototype.get);\n  const setHas = uncurryThis(Set.prototype.has);\n\n  const errorNameToErrorConstructor = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n  const errorConstructors = new Set([\n    EvalError.prototype,\n    RangeError.prototype,\n    ReferenceError.prototype,\n    SyntaxError.prototype,\n    TypeError.prototype,\n    URIError.prototype,\n    Error.prototype\n  ]);\n\n  function callAndWrapError(target, args) {\n    try {\n      return apply(target, undefined, args);\n    } catch (err) {\n      // 1. Thrown primitives\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n\n      // 2. Current realm errors\n      if (setHas(errorConstructors, getPrototypeOf(err))) {\n        // err is a from the current realm, which is safe to rethrow.\n        // Object instances (normally) only contain intrinsics from the\n        // same realm. An error containing intrinsics from different\n        // realms would have to be manually constucted, which imply that\n        // such intrinsics were available, and confinement was already lost.\n        throw err;\n      }\n\n      // 3. Other realm errors\n      let eName, eMessage, eStack;\n      try {\n        // The other environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. In addition, exceptions\n        // raised in the primal realm need to be converted to the current\n        // realm.\n\n        // `${err.name}` will cause string coercion of 'err.name'.\n        // If err.name is an object (probably a String of another Realm),\n        // the coercion uses err.name.toString(), which is under the control\n        // of the other realm. If err.name were a primitive (e.g. a number),\n        // it would use Number.toString(err.name), using the child's version\n        // of Number (which the child could modify to capture its argument for\n        // later use), however primitives don't have properties like .prototype\n        // so they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now realm-independent primitive strings, and\n        // safe to expose.\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away.\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor =\n        mapGet(errorNameToErrorConstructor, eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  return callAndWrapError;\n}\n\nexport const buildCallAndWrapErrorString = safeStringifyFunction(\n  buildCallAndWrapError\n);\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(\n  unsafeGlobal,\n  configurableGlobals = false\n) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  if (configurableGlobals) {\n    describe(frozenGlobalPropertyNames, true, false, true);\n    // The following is correct but expensive.\n    describe(stableGlobalPropertyNames, true, false, true);\n  } else {\n    // Instead, for now, we let these get optimized.\n    describe(frozenGlobalPropertyNames, false, false, false);\n    describe(stableGlobalPropertyNames, false, false, false);\n  }\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  const { apply } = Reflect;\n  const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n  // %Object.prototype.valueOf% performs:\n  // 1. Return ? ToObject(this value)\n  const toObject = uncurryThis(objectPrototype.valueOf);\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  // We use the the concise method syntax to create methods without\n  // a [[Construct]] internal method (such that the invocation\n  // \"new __method__()\" throws \"TypeError: __method__ is not a constructor\"),\n  // but which still accepts a 'this' binding.\n  const {\n    __defineGetter__,\n    __defineSetter__,\n    __lookupGetter__,\n    __lookupSetter__\n  } = {\n    // eslint-disable-next-line no-underscore-dangle\n    __defineGetter__(prop, func) {\n      const O = toObject(this);\n      defineProperty(O, prop, {\n        get: aFunction(func, 'getter'),\n        enumerable: true,\n        configurable: true\n      });\n    },\n\n    // eslint-disable-next-line no-underscore-dangle\n    __defineSetter__(prop, func) {\n      const O = toObject(this);\n      defineProperty(O, prop, {\n        set: aFunction(func, 'setter'),\n        enumerable: true,\n        configurable: true\n      });\n    },\n\n    // eslint-disable-next-line no-underscore-dangle\n    __lookupGetter__(prop) {\n      let O = toObject(this);\n      prop = asPropertyName(prop);\n      let desc;\n      while (O !== null && !(desc = getOwnPropertyDescriptor(O, prop))) {\n        O = getPrototypeOf(O);\n      }\n      return desc && desc.get;\n    },\n\n    // eslint-disable-next-line no-underscore-dangle\n    __lookupSetter__(prop) {\n      let O = toObject(this);\n      prop = asPropertyName(prop);\n      let desc;\n      while (O !== null && !(desc = getOwnPropertyDescriptor(O, prop))) {\n        O = getPrototypeOf(O);\n      }\n      return desc && desc.set;\n    }\n  };\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: { value: __defineGetter__ },\n    __defineSetter__: { value: __defineSetter__ },\n    __lookupGetter__: { value: __lookupGetter__ },\n    __lookupSetter__: { value: __lookupSetter__ }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = (0, eval)(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { buildCallAndWrapErrorString } from './callAndWrapError';\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { safeStringifyFunction } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(\n  unsafeGlobal,\n  allShims = [],\n  configurableGlobals = false\n) {\n  const sharedGlobalDescs = getSharedGlobalDescs(\n    unsafeGlobal,\n    configurableGlobals\n  );\n\n  const unsafeEval = unsafeGlobal.eval;\n  const unsafeFunction = unsafeGlobal.Function;\n  const callAndWrapError = unsafeEval(buildCallAndWrapErrorString)();\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval,\n    unsafeFunction,\n    callAndWrapError,\n    allShims\n  });\n}\n\nconst repairAccessorsString = safeStringifyFunction(repairAccessors);\nconst repairFunctionsString = safeStringifyFunction(repairFunctions);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims, configurableGlobals = false) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  const unsafeRec = createUnsafeRec(\n    unsafeGlobal,\n    allShims,\n    configurableGlobals\n  );\n  const { unsafeEval } = unsafeRec;\n  unsafeEval(repairAccessorsString)();\n  unsafeEval(repairFunctionsString)();\n  return unsafeRec;\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeEval = eval;\n  const unsafeGlobal = unsafeEval(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(globalObject, localObject = {}) {\n  const globalNames = getOwnPropertyNames(globalObject);\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(globalNames, name => {\n    // Exclude globals that will be hidden behind an object positioned\n    // closer in the resolution scope chain, typically the endowments.\n    if (name in localObject) {\n      return false;\n    }\n\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = getOwnPropertyDescriptor(globalObject, name);\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { safeStringifyFunction } from './utilities';\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n *\n * @returns {ProxyHandler<any> & Record<string, any>}\n */\nexport function buildScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments = {},\n  sloppyGlobals = false\n) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  const { freeze, getOwnPropertyDescriptor } = Object;\n  const { get: reflectGet, set: reflectSet } = Reflect;\n\n  /**\n   * alwaysThrowHandler is a proxy handler which throws on any trap called.\n   * It's made from a proxy with a get trap that throws. Its target is\n   * an immutable (frozen) object and is safe to share, except accross realms\n   */\n  const alwaysThrowHandler = new Proxy(freeze({}), {\n    get(target, prop) {\n      // todo: replace with throwTantrum\n      throw new TypeError(\n        `unexpected scope handler trap called: ${String(prop)}`\n      );\n    }\n  });\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    // This flag allow us to determine if the eval() call is an done by the\n    // realm's code or if it is user-land invocation, so we can react differently.\n    // We use a property and not an accessor to avoid increasing the stack trace\n    // and reduce the possibility of OOM.\n    useUnsafeEvaluator: false,\n\n    get(shadow, prop) {\n      if (typeof prop === 'symbol') {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (this.useUnsafeEvaluator === true) {\n          // revoke before use\n          this.useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        // fall through\n      }\n\n      // Properties of the endowments.\n      if (prop in endowments) {\n        // Ensure that the 'this' value on getters resolves\n        // to the safeGlobal, not to the endowments object.\n        return reflectGet(endowments, prop, safeGlobal);\n      }\n\n      // Properties of the global.\n      return reflectGet(safeGlobal, prop);\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(shadow, prop, value) {\n      // Properties of the endowments.\n      if (prop in endowments) {\n        const desc = getOwnPropertyDescriptor(endowments, prop);\n        if ('value' in desc) {\n          // Work around a peculiar behavior in the specs, where\n          // value properties are defined on the receiver.\n          return reflectSet(endowments, prop, value);\n        }\n        // Ensure that the 'this' value on setters resolves\n        // to the safeGlobal, not to the endowments object.\n        return reflectSet(endowments, prop, value, safeGlobal);\n      }\n\n      // Properties of the global.\n      return reflectSet(safeGlobal, prop, value);\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(shadow, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (\n        prop === 'eval' ||\n        prop in endowments ||\n        prop in safeGlobal ||\n        prop in unsafeGlobal\n      ) {\n        return true;\n      }\n\n      return false;\n    },\n\n    // note: this is likely a bug of safari\n    // https://bugs.webkit.org/show_bug.cgi?id=195534\n\n    getPrototypeOf() {\n      return null;\n    }\n  };\n}\n\nexport const buildScopeHandlerString = safeStringifyFunction(buildScopeHandler);\n","import { safeStringifyFunction } from './utilities';\n\nfunction buildSafeEval(unsafeRec, safeEvalOperation) {\n  const { callAndWrapError } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  // We use the the concise method syntax to create an eval without a\n  // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n  // TypeError: eval is not a constructor\"), but which still accepts a\n  // 'this' binding.\n  const safeEval = {\n    eval() {\n      return callAndWrapError(safeEvalOperation, arguments);\n    }\n  }.eval;\n\n  // safeEval's prototype RootRealm's value and instanceof Function\n  // is true inside the realm. It doesn't point at the primal realm\n  // value, and there is no defense against leaking primal realm\n  // intrinsics.\n\n  defineProperties(safeEval, {\n    toString: {\n      // We break up the following literal string so that an\n      // apparent direct eval syntax does not appear in this\n      // file. Thus, we avoid rejection by the overly eager\n      // rejectDangerousSources.\n      value: () => `function ${'eval'}() { [shim code] }`,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeEval;\n}\nexport const buildSafeEvalString = safeStringifyFunction(buildSafeEval);\n","import { safeStringifyFunction } from './utilities';\n\nfunction buildSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { callAndWrapError, unsafeFunction } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  const safeFunction = function Function() {\n    return callAndWrapError(safeFunctionOperation, arguments);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: () => 'function Function() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\nexport const buildSafeFunctionString = safeStringifyFunction(buildSafeFunction);\n","import { safeStringifyFunction } from './utilities';\n\nexport function applyTransforms(rewriterState, transforms) {\n  const { create, getOwnPropertyDescriptors } = Object;\n  const { apply } = Reflect;\n  const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n  const arrayReduce = uncurryThis(Array.prototype.reduce);\n\n  // Clone before calling transforms.\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  // Rewrite the source, threading through rewriter state as necessary.\n  rewriterState = arrayReduce(\n    transforms,\n    (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n    rewriterState\n  );\n\n  // Clone after transforms\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  return rewriterState;\n}\n\nexport const applyTransformsString = safeStringifyFunction(applyTransforms);\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\n// Still allow JSDocs that use `import()` such as:\n// * @param {import('./foo.js').MyType}\n// * @param {typeof import('./foo.js').Obj}\n//\n// Note that this is not valid syntax outside of a comment\n// (import expressions cannot be the start of an object literal,\n// nor can decorators adorn blocks).\n//\n// Also note that the dollar at the end matches where the import begins\n// since the 's' modifier is given.\n//\n// BE CAREFUL not to use `\\s`, as that will match newlines.\nconst allowedImportPrefix = /@[a-z]+ +\\{((type|key)of +)?$/s;\n\nfunction rejectImportExpressions(s) {\n  let index = 0;\n  for (;;) {\n    // Find the next `import` string in the source.\n    const nextMatch = s.slice(index).search(importPattern);\n    if (nextMatch === -1) {\n      // Not found, the source is okay.\n      return;\n    }\n    // Advance our index to the beginning of `import`.\n    index += nextMatch;\n    // Take the source up to the match, and see if\n    // it ends in the allowed prefix.\n    if (s.slice(0, index).match(allowedImportPrefix)) {\n      // Move the search one character forward, and go again.\n      index += 1;\n      continue;\n    }\n    // It doesn't end in the allowed prefix, so reject the source entirely.\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport { assert, throwTantrum } from './utilities';\nimport {\n  apply,\n  arrayConcat,\n  arrayJoin,\n  arrayPop,\n  getPrototypeOf,\n  regexpTest,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { buildScopeHandlerString } from './scopeHandler';\nimport { buildSafeEvalString } from './safeEval';\nimport { buildSafeFunctionString } from './safeFunction';\nimport { applyTransformsString } from './transforms';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const { unsafeEval } = unsafeRec;\n  const applyTransforms = unsafeEval(applyTransformsString);\n\n  function factory(endowments = {}, options = {}) {\n    // todo clone all arguments passed to returned function\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = arrayConcat(\n      localTransforms,\n      realmTransforms,\n      mandatoryTransforms\n    );\n\n    function safeEvalOperation(src) {\n      let rewriterState = { src, endowments };\n      rewriterState = applyTransforms(rewriterState, allTransforms);\n\n      // Combine all optimizable globals.\n      const globalConstants = getOptimizableGlobals(\n        safeGlobal,\n        rewriterState.endowments\n      );\n      const localConstants = getOptimizableGlobals(rewriterState.endowments);\n      const constants = arrayConcat(globalConstants, localConstants);\n\n      const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n        unsafeRec,\n        constants\n      );\n\n      const scopeHandler = unsafeEval(buildScopeHandlerString)(\n        unsafeRec,\n        safeGlobal,\n        rewriterState.endowments,\n        sloppyGlobals\n      );\n      const scopeProxyRevocable = Proxy.revocable({}, scopeHandler);\n      const scopeProxy = scopeProxyRevocable.proxy;\n      const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n        scopeProxy\n      ]);\n\n      scopeHandler.useUnsafeEvaluator = true;\n      let err;\n      try {\n        // Ensure that \"this\" resolves to the safe global.\n        return apply(scopedEvaluator, safeGlobal, [rewriterState.src]);\n      } catch (e) {\n        // stash the child-code error in hopes of debugging the internal failure\n        err = e;\n        throw e;\n      } finally {\n        if (scopeHandler.useUnsafeEvaluator) {\n          // the proxy switches this off immediately after ths\n          // first access, but if that's not the case we prevent\n          // further variable resolution on the scope and abort.\n          scopeProxyRevocable.revoke();\n          throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n        }\n      }\n    }\n\n    return safeEvalOperation;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeEval, unsafeFunction } = unsafeRec;\n\n  const safeEval = unsafeEval(buildSafeEvalString)(\n    unsafeRec,\n    safeEvalOperation\n  );\n\n  assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n  assert(\n    getPrototypeOf(safeEval).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeEval;\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeGlobal, unsafeEval, unsafeFunction } = unsafeRec;\n\n  function safeFunctionOperation(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEvalOperation(src);\n  }\n\n  const safeFunction = unsafeEval(buildSafeFunctionString)(\n    unsafeRec,\n    safeFunctionOperation\n  );\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeFunction;\n}\n","import { buildChildRealm, buildChildRealmString } from './childRealm';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEvalOperation = safeEvaluatorFactory();\n  const safeEval = createSafeEvaluator(unsafeRec, safeEvalOperation);\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEvalOperation);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const {\n    shims: newShims,\n    transforms,\n    sloppyGlobals,\n    configurableGlobals\n  } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims, configurableGlobals);\n  const { unsafeEval } = unsafeRec;\n\n  const Realm = unsafeEval(buildChildRealmString)(\n    unsafeRec,\n    // eslint-disable-next-line no-use-before-define\n    BaseRealm\n  );\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n"],"names":[],"mappings":"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"}